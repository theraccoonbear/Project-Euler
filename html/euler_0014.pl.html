<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by perltidy on Fri Jan 22 09:48:06 2010 -->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>euler_0014.pl</title>
<style type="text/css">
<!--
/* default style sheet generated by perltidy */
body {background: #FFFFFF; color: #000000}
pre { color: #000000; 
      background: #FFFFFF;
      font-family: courier;
    } 

.c  { color: #228B22;} /* comment */
.cm { color: #000000;} /* comma */
.co { color: #000000;} /* colon */
.h  { color: #CD5555; font-weight:bold;} /* here-doc-target */
.hh { color: #CD5555; font-style:italic;} /* here-doc-text */
.i  { color: #00688B;} /* identifier */
.j  { color: #CD5555; font-weight:bold;} /* label */
.k  { color: #8B008B; font-weight:bold;} /* keyword */
.m  { color: #FF0000; font-weight:bold;} /* subroutine */
.n  { color: #B452CD;} /* numeric */
.p  { color: #000000;} /* paren */
.pd { color: #228B22; font-style:italic;} /* pod-text */
.pu { color: #000000;} /* punctuation */
.q  { color: #CD5555;} /* quote */
.s  { color: #000000;} /* structure */
.sc { color: #000000;} /* semicolon */
.v  { color: #B452CD;} /* v-string */
.w  { color: #000000;} /* bareword */
-->
</style>
</head>
<body>
<a name="-top-"></a>
<h1>euler_0014.pl</h1>
<!-- BEGIN CODE INDEX --><a name="code-index"></a>
<ul>
<li><a href="#nextVal-">package main</a>
<ul>
<li><a href="#nextVal-">nextVal</a></li>
<li><a href="#chainLength-">chainLength</a></li>
</ul>
</li>
<li><a href="#EOF-">EOF</a></li>
</ul>
<!-- END CODE INDEX -->
<hr />
<!-- contents of filename: euler_0014.pl -->
<pre>
#!/opt/local/bin/perl

<span class="c"># Project Euler Problem #14</span>
<span class="c">#</span>
<span class="c"># The following iterative sequence is defined for the set of positive integers:</span>
<span class="c"># </span>
<span class="c"># n -&gt; n/2 (n is even)</span>
<span class="c"># n -&gt; 3n + 1 (n is odd)</span>
<span class="c"># </span>
<span class="c"># Using the rule above and starting with 13, we generate the following sequence:</span>
<span class="c"># 13 -&gt; 40 -&gt; 20 -&gt; 10 -&gt; 5 -&gt; 16 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1</span>
<span class="c"># </span>
<span class="c"># It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.</span>
<span class="c"># </span>
<span class="c"># Which starting number, under one million, produces the longest chain?</span>
<span class="c"># </span>
<span class="c"># NOTE: Once the chain starts the terms are allowed to go above one million.</span>


<span class="k">use</span> <span class="w">strict</span><span class="sc">;</span>
<span class="k">use</span> <span class="w">warnings</span><span class="sc">;</span>
<span class="k">require</span> <span class="q">&quot;/Users/don/bin/scripts/euler/functions.pm&quot;</span><span class="sc">;</span>

<span class="k">sub </span><span class="m">nextVal($)</span><span class="sc">;</span>
<span class="k">sub </span><span class="m">chainLength($)</span><span class="sc">;</span>

<span class="c"># Disable output buffering</span>
<span class="k">select</span><span class="s">(</span><span class="s">(</span><span class="k">select</span><span class="s">(</span><span class="w">STDOUT</span><span class="s">)</span><span class="cm">,</span> <span class="i">$|</span>=<span class="n">1</span><span class="s">)</span>[<span class="n">0</span>]<span class="s">)</span><span class="sc">;</span>

<span class="k">my</span> <span class="i">@memo</span> = <span class="s">(</span><span class="s">)</span><span class="sc">;</span>

<a name="nextVal-"></a><span class="k">sub </span><span class="m">nextVal($)</span> <span class="s">{</span>
  <span class="k">my</span> <span class="i">$val</span> = <span class="k">shift</span> <span class="i">@_</span><span class="sc">;</span>
  
  <span class="k">if</span> <span class="s">(</span><span class="i">$val</span> % <span class="n">2</span> == <span class="n">0</span><span class="s">)</span> <span class="s">{</span>
    <span class="k">return</span> <span class="i">$val</span> / <span class="n">2</span><span class="sc">;</span>
  <span class="s">}</span> <span class="k">else</span> <span class="s">{</span>
    <span class="k">return</span> <span class="i">$val</span> * <span class="n">3</span> + <span class="n">1</span><span class="sc">;</span>
  <span class="s">}</span>
<span class="s">}</span> <span class="c"># next()</span>

<a name="chainLength-"></a><span class="k">sub </span><span class="m">chainLength($)</span> <span class="s">{</span>
  <span class="k">my</span> <span class="i">$val</span> = <span class="k">shift</span><span class="s">(</span><span class="i">@_</span><span class="s">)</span><span class="sc">;</span>
  <span class="k">my</span> <span class="i">$orig</span> = <span class="i">$val</span><span class="sc">;</span>
  <span class="k">my</span> <span class="i">$chain</span> = <span class="n">1</span><span class="sc">;</span>
  
  <span class="i">dbgMsg</span><span class="s">(</span><span class="q">&quot;------ASSESSING: $val\n&quot;</span><span class="s">)</span><span class="sc">;</span>
  
  <span class="k">while</span> <span class="s">(</span><span class="i">$val</span> != <span class="n">1</span><span class="s">)</span> <span class="s">{</span>
    <span class="k">if</span> <span class="s">(</span><span class="k">defined</span> <span class="i">$memo</span>[<span class="i">$val</span>]<span class="s">)</span> <span class="s">{</span>
      <span class="i">dbgMsg</span><span class="s">(</span><span class="q">&quot;Cache hit for $val is chain length of $memo[$val] yielding &quot;</span> . <span class="s">(</span><span class="i">$memo</span>[<span class="i">$val</span>] + <span class="i">$chain</span><span class="s">)</span> .<span class="q">&quot; for $orig\n&quot;</span><span class="s">)</span><span class="sc">;</span>
      <span class="i">$memo</span>[<span class="i">$orig</span>] = <span class="i">$memo</span>[<span class="i">$val</span>] + <span class="i">$chain</span><span class="sc">;</span>
      <span class="k">return</span> <span class="i">$memo</span>[<span class="i">$orig</span>]<span class="sc">;</span>
    <span class="s">}</span> <span class="k">else</span> <span class="s">{</span>
      <span class="i">$val</span> = <span class="i">nextVal</span><span class="s">(</span><span class="i">$val</span><span class="s">)</span><span class="sc">;</span>
      <span class="i">$chain</span>++<span class="sc">;</span>
    <span class="s">}</span>
  <span class="s">}</span>
  
  <span class="i">dbgMsg</span><span class="s">(</span><span class="q">&quot;Caching chain length of $chain for value of $orig\n&quot;</span><span class="s">)</span><span class="sc">;</span>
  <span class="i">$memo</span>[<span class="i">$orig</span>] = <span class="i">$chain</span><span class="sc">;</span>
  
  <span class="k">return</span> <span class="i">$memo</span>[<span class="i">$orig</span>]<span class="sc">;</span>
<span class="s">}</span> <span class="c"># chainLength()</span>

<span class="k">my</span> <span class="i">$longest_chain</span> = <span class="n">0</span><span class="sc">;</span>
<span class="k">my</span> <span class="i">$longest_chain_init</span> = <span class="n">0</span><span class="sc">;</span>
<span class="k">my</span> <span class="i">$x</span> = <span class="n">0</span><span class="sc">;</span>
<span class="k">my</span> <span class="i">$chain</span> = <span class="n">0</span><span class="sc">;</span>

<span class="i">startTiming</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span>

<span class="i">debugOn</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span>

<span class="k">for</span> <span class="s">(</span><span class="i">$x</span> = <span class="n">1</span><span class="sc">;</span> <span class="i">$x</span> &lt;= <span class="n">1000000</span><span class="sc">;</span> <span class="i">$x</span>++<span class="s">)</span> <span class="s">{</span>
  <span class="i">$chain</span> = <span class="i">chainLength</span><span class="s">(</span><span class="i">$x</span><span class="s">)</span><span class="sc">;</span>
  
  <span class="k">if</span> <span class="s">(</span><span class="i">$chain</span> &gt; <span class="i">$longest_chain</span><span class="s">)</span> <span class="s">{</span>
     <span class="i">dbgMsg</span><span class="s">(</span><span class="q">&quot;\n\n        New longest chain for value $x found to be $chain\n\n&quot;</span><span class="s">)</span><span class="sc">;</span>
     <span class="c">#sleep 1;</span>
     <span class="i">$longest_chain</span> = <span class="i">$chain</span><span class="sc">;</span>
     <span class="i">$longest_chain_init</span> = <span class="i">$x</span><span class="sc">;</span>
  <span class="s">}</span>
  
<span class="s">}</span>

<span class="k">print</span> <span class="q">&quot;\n\n&quot;</span> . <span class="i">endTiming</span><span class="s">(</span><span class="s">)</span> . <span class="q">&quot; seconds elapsed\n\n&quot;</span><span class="sc">;</span>

<span class="k">print</span> <span class="q">&quot;\nLongest chain of $longest_chain starting from $longest_chain_init.\n\n&quot;</span><span class="sc">;</span>

<span class="c"># Answer: 837799</span>
<a name="EOF-"></a></pre>
</body>
</html>
