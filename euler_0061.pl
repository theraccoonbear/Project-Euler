#!/opt/local/bin/perl

# Project Euler Problem #61
# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
# Triangle 	  	P_(3,n)=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
# Square 	  	P_(4,n)=n^(2) 	  	1, 4, 9, 16, 25, ...
# Pentagonal 	  	P_(5,n)=n(3n-1)/2 	  	1, 5, 12, 22, 35, ...
# Hexagonal 	  	P_(6,n)=n(2n-1) 	  	1, 6, 15, 28, 45, ...
# Heptagonal 	  	P_(7,n)=n(5n-3)/2 	  	1, 7, 18, 34, 55, ...
# Octagonal 	  	P_(8,n)=n(3n-2) 	  	1, 8, 21, 40, 65, ...
# 
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
# 
#    1. The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
#    2. Each polygonal type: triangle (P_(3,127)=8128), square (P_(4,91)=8281), and pentagonal (P_(5,44)=2882), is represented by a different number in the set.
#    3. This is the only set of 4-digit numbers with this property.
# 
# Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
# octagonal, is represented by a different number in the set.
# 
use strict;
use warnings;
use List::Util qw[min max reduce];
require "functions.pm";


# Disable output buffering
select((select(STDOUT), $|=1)[0]);

my $answer = '';

my $tl = 4;

my %pbt;

my @l_tri;
my @l_squ;
my @l_pen;
my @l_hex;
my @l_hep;
my @l_oct;
my @l_all;

sub isCyclic($) {
  my @nums = @{shift @_};
  
  if (isLinear(\@nums)) {
    my $need = substr($nums[$#nums], -2);
    
    if ($need ne substr($nums[0], 0, 2)) {
      return 0;
    } else {
      return 1;
    }
  } else {
    return 0
  }
} # isCyclic()

sub isLinear($)  {
  my @nums = @{shift @_};
  my $need = substr($nums[0], -2);
  
  if (scalar @nums == 1) { print "ACK\n\n"; return 1; }
  
  #dbgMsg("\nIN: " . join(', ', @nums) . "\n");

  for (my $i = 1; $i < scalar @nums; $i++) {
    my $check = substr($nums[$i], 0, 2);
    #dbgMsg("$check == $need\n");
    if ($check ne $need) {
      return 0;
    }
    $need = substr($nums[$i], -2);
  }
  
  return 1;
} # isLinear()

sub valInList($$) {
  my $val = shift @_;
  my @list = @{shift @_};
  my %cnt;
  
  map $cnt{$_}++, @list;
  
  return (defined $cnt{$val} && $cnt{$val} >= 1);
} # valInList()

sub findLinears($) {
  my $val = shift @_;
  my $ltd = substr($val, -2);
  my @ta = ();
  my $dbg = 0;
  if ($ltd == 82) {
    $dbg = 1;
  }
  
  for my $n (@l_all) {
    if (substr($n, 0, 2) eq $ltd) {
      push @ta, $n;
    }
  }
  
  return @ta;
} # findLinears()



startTiming();

dbgMsg("Generating $tl digit polynomial numbers...\n");

for (my $n = 0; $n < 150; $n++) {
  my $tri = triNum($n);
  my $square = squareNum($n);
  my $pent = pentNum($n);
  my $hex = hexNum($n);
  my $hept = heptNum($n);
  my $oct = octNum($n);
  
  if (length($tri) == $tl) { $pbt{$tri} .= 3; push @l_tri, $tri; }
  if (length($square) == $tl) { $pbt{$square} .= 4; push @l_squ, $square; }
  if (length($pent) == $tl) { $pbt{$pent} .= 5; push @l_pen, $pent; }
  if (length($hex) == $tl) { $pbt{$hex} .= 6; push @l_hex, $hex; }
  if (length($hept) == $tl) { $pbt{$hept} .= 7; push @l_hep, $hept; }
  if (length($oct) == $tl) { $pbt{$oct} .= 8; push @l_oct, $oct; }
  tick(':)');
}


@l_all = sort (@l_tri, @l_squ, @l_pen, @l_hex, @l_hep, @l_oct);

#print join("\n", sort @l_all); exit 0;


dbgMsg("\n...done\n");
dbgMsg("Tracing cyclicity...\n");

my @cyclic = ();
my $done = 0;
my %used;

my $circuit_len = 6;
my $i = 0;
my $n;


sub getNext($) {
  my @vals = @{shift @_};
  my $ln = $vals[$#vals];
  my $on_track = 0;
  
  my @linears = findLinears($ln);
  
  dbgMsg("This Far: " . join(', ', @vals) . "\n");

  
  for (my $i = 0; $i < scalar @linears; $i++) { #(@linears) {
    my $n = $linears[$i];
    if (!defined $used{substr($pbt{$n}, 0, 1)}) {
      push @vals, $n;
      $used{substr($pbt{$n}, 0, 1)} = 1;
      if (scalar @vals == $circuit_len) {
        if (isCyclic(\@vals)) {
          return @vals;
        } else {
          pop @vals;
          delete $used{substr($pbt{$n}, 0, 1)};
        }
      } else {
        @vals = getNext(\@vals);
        if (scalar @vals == $circuit_len) {
          if (isCyclic(\@vals)) {
            return @vals;
          }
        }
      }
    }
  }
  delete $used{substr($pbt{pop @vals}, 0, 1)};
  return @vals;
} # getNext()

for ($i = 0; $i < scalar @l_all; $i++) {
  push @cyclic, $l_all[$i];
  $used{substr($pbt{$l_all[$i]}, 0, 1)} = 1;
  @cyclic = getNext(\@cyclic);
  if (scalar @cyclic == $circuit_len) {
    last;
  }
  #if (scalar 
  #pop @cyclic;
}


dbgMsg("\n...done\n");

dbgMsg("Series: " . join(', ', @cyclic) . "\n");
dbgMsg("Groups: " . join(', ', map $pbt{$_}, @cyclic) . "\n");
$answer = reduce {$a + $b} @cyclic;

print "\n\nAnswer: $answer\n\n";

endTiming();


# Answer: 28684